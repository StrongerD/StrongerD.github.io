<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MVVM实现原理]]></title>
    <url>%2F2019%2F09%2F02%2FMVVM%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[MVVM原理实现在实现MVVM之前我们先来了解一下MVVM和MVC模式的差异 一、MVVM vs MVCMVC模式 View(视图)： 用户界面 Controller(控制器): 业务逻辑 Model(模型): 数据保存 MVC允许在不改变视图的情况下改变视图对用户输入的相应方式，用户对View的操作交给了Contoller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。 Mvc模式的业务逻辑主要集中在Controller 在没有现在那么多前端框架的情况下，Mvc模式可以这样理解。将HTML看作是View，js是controller，负责处理用户与应用的交互，响应对view的操作，调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作），将js的ajax当作model，也即是数据层，通过ajax从服务器获取数据。 MVVM模式 Model(模型): 数据保存 View(视图): 用户界面 ViewModel: view和model的连接器, 通过他实现双向绑定 MVVM与MVC最大的区别就是： 它实现了View和Model的自动同步，也就是当Model的属性发生改变时，我们不需要像以前一样手动操作D om去改变View，Model的属性在改变后他会自动进行视图的更新。这就是神奇的双向绑定 二、双向绑定实现原理目前实现双向绑定主流的几种方法主要有 1.发布订阅者：通过pub，sub的方式实现数据和视图绑定监听。 2.脏值检测： 通过数据比对的方式进行检测数据是否有更新，最简单的方式肯定会是通过轮询的方式。angular采用的方式是只有在指定的事件触发之后才会进行脏值检测，比如：用户输入文本 http事件等。 3.数据劫持：vue主要采用的是数据劫持结合发布-订阅者模式，通过es5的Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，出发相应的监听回调。 要实现MVVM的双向绑定需要实现以下几点： 1.实现一个数据监听器 Observe，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 2.实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 3.实现一个Watcher，作为连接Observe和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 1.实现Observe123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var data = &#123;name: kidding&#125;;observe(data);data.name = &apos;yes&apos;;funtion observe(data) &#123; if (!data || type data !== &apos;Object&apos;) &#123; return; &#125; Object.keys(data).forEach(function()&#123; defineReactive(data, key, data[key]); &#125;)&#125;function defineReactive(data, key, val) &#123; var dep = new Dep(); observe(val); object.defineProperty(data, key, &#123; enumerable: true, configurable: false, get: function() &#123; Dep.target &amp;&amp; dep.addDep(Dep.target); return val; &#125;, set: function(newVal) &#123; if (val === newVal) &#123; return; &#125; console.log(val, &apos;---&gt;&apos;, newVal); val = newVal; dep.notify(); &#125; &#125;)&#125;function Dep() &#123; this.subs = [];&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub) &#125;, notify: function() &#123; this.subs.forEach(function(i)&#123; i.update(); &#125;) &#125;&#125;Watcher.prototype = &#123; get: function(key) &#123; Dep.target = this; this.value = data[key]; Dep.target = null; &#125;&#125; 2.实现Compilecompile主要做的事情就是解析模板指令，将模板中的变量替换为真实的数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知更新视图。 因为解析遍历的过程有多次操作Dom，需要将实例根节点的el转换成文档碎片fragment进行解析编译操作。解析完成之后在将fragment添加回真是的dom节点中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function Compile(el) &#123; this.$el = this.isElementNode(el) ? el : document.querySelector(el); if (this.$el) &#123; this.$fragment = this.node2Fragment(this.$el); this.init(); this.$el.appendChild(this.$fragment); &#125;&#125;Compile.prototype = &#123; init: function() &#123; this.compileElement(this.$fragment); &#125;, node2Fragment: function(el) &#123; var fragment = document.createDocumentFragment(), child; while(child = el.firstChild) &#123; fragment.appendChild(); &#125; return fragment; &#125;, compileElement: function(el) &#123; var childNodes = el.childNodes, me = this; [].splice.call(childNodes).forEach(function(node)&#123; var text = node.textContent; var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; if (me.isElementNode(node)) &#123; me.compile(node); &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123; me.compileText(node, RegExp.$1); &#125; if (node.childNodes &amp;&amp; node.childNodes.length) &#123; me.compileElement(node); &#125; &#125;) &#125;, compile: function(node) &#123; var nodeAttrs = node.attributes, me = this; [].splice.call(nodeAttrs).forEach(function(attr)&#123; var attrName = attr.name; if (me.isDirective(attrName)) &#123; var exp = attr.value; var dir = attrName.substring(2); if (me.isEventDirective(dir)) &#123; compileUtil.eventHandler(node, me.$vm, exp, dir); &#125; else &#123; compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp); &#125; &#125; &#125;) &#125;&#125;var compileUtil = &#123; text: function(node, vm, exp) &#123; this.bind(node, vm, exp, &apos;text&apos;); &#125;, bind: function(node, vm, exp, dir) &#123; var updaterFn = udater[dir + &apos;Updater&apos;]; updaterFn &amp;&amp; updaterFn(node, vm[exp]); new Watcher(vm, exp, function(value, oldValue) &#123; // 一旦属性值有变化，会收到通知执行此更新函数，更新视图 updaterFn &amp;&amp; updaterFn(node, value, oldValue); &#125;); &#125;&#125;var updater = &#123; textUpdater: function(node, value) &#123; node.textContent = typeof value == &apos;undefined&apos; ? &apos;&apos; : value; &#125; // ...省略&#125;; 3.实现WatcherWatcher订阅者作为Observe和Compile之间通信的桥梁，主要做的事情是： 1.在自身实例化往属性订阅器dep里面添加自己 2.自身必须有一个update()方法 3.待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调 1234567891011121314151617181920212223242526function Watcher(vm, exp, cb) &#123; this.cb = cb; this.vm = vm; this.exp = exp; // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解 this.value = this.get(); &#125;Watcher.prototype = &#123; update: function() &#123; this.run(); // 属性值变化收到通知 &#125;, run: function() &#123; var value = this.get(); // 取到最新值 var oldVal = this.value; if (value !== oldVal) &#123; this.value = value; this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图 &#125; &#125;, get: function() &#123; Dep.target = this; // 将当前订阅者指向自己 var value = this.vm[exp]; // 触发getter，添加自己到属性订阅器中 Dep.target = null; // 添加完毕，重置 return value; &#125;&#125;; 实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。 基本上vue中数据绑定相关比较核心的几个模块也是这几个，猛戳这里 , 在src 目录可找到vue源码。]]></content>
      <tags>
        <tag>js, vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC布局]]></title>
    <url>%2F2019%2F07%2F03%2FBFC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[BFC(块级格式化上下文) 是web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互区域。 触发条件 根元素, 即HTML元素 float的值不为none overflow的值不为visible display的值为inline-block, table-cell, table-caption position的值为absolute或fixed 布局规则 内部的box会在垂直方向, 一个接一个地放置(这点就是我们常见到的块级元素占一行) box的垂直方向的距离由margin决定, 属于同一个BFC的两个相邻的margin会发生重叠, 与方向无关(垂直方向上的margin重合也就是我们常说的“坍塌现象”) 每个元素的margin box的左边, 与包含border box的左边相接触(对于从左往右的格式化, 否则相反). 即使存在浮动也是如此 BFC的区域不会与float box重叠 BFC就是页面上的一个隔壁的独立容器, 容器里面的子元素不会影响到外面的元素. 反之也如此 计算BFC的高度时, 浮动元素也参与计算 对比初学css时的规则 block元素会扩展到与父元素同宽, 所以block元素会垂直排列 垂直方向上两个相邻的DIV margin重叠, 而水平方向上不会(这个说法就不完全正确) 浮动元素会接近左上方或右上方 为父元素设置overflow: hidden 或浮动元素, 则会包含浮动元素 初学CSS规则背后更深层次的概念其实就是BFC布局规则 作用 自适应的两栏布局 可以阻止元素被浮动元素覆盖 可以包含浮动元素——清除内部浮动 分属不同的BFC时可以阻止margin重叠 通过BFC实现两栏布局12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .box &#123; height: 100%; width: 100%; &#125; .left &#123; float: left; height: 200px; background-color: aquamarine; width: 300px; margin-right: 20px; &#125; .right &#123; height: 300px; background-color: blueviolet; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
