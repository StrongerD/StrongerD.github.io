<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不砍树的强哥</title>
  
  <subtitle>记录探索的点滴😼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-02T01:28:07.408Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Stronger Duan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MVVM实现原理</title>
    <link href="http://yoursite.com/2019/09/02/MVVM%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/02/MVVM实现原理/</id>
    <published>2019-09-02T01:26:14.000Z</published>
    <updated>2019-09-02T01:28:07.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MVVM原理实现"><a href="#MVVM原理实现" class="headerlink" title="MVVM原理实现"></a>MVVM原理实现</h2><p>在实现MVVM之前我们先来了解一下MVVM和MVC模式的差异</p><h3 id="一、MVVM-vs-MVC"><a href="#一、MVVM-vs-MVC" class="headerlink" title="一、MVVM vs MVC"></a>一、MVVM vs MVC</h3><h4 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h4><blockquote><p>View(视图)： 用户界面 <br><br>Controller(控制器): 业务逻辑 <br><br>Model(模型): 数据保存</p></blockquote><p><img src="https://lc-gold-cdn.xitu.io/9da7ababda36b88a5dd7.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><a id="more"></a><p>MVC允许在不改变视图的情况下改变视图对用户输入的相应方式，用户对View的操作交给了Contoller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。</p><p>Mvc模式的业务逻辑主要集中在Controller</p><p>在没有现在那么多前端框架的情况下，Mvc模式可以这样理解。将HTML看作是View，js是controller，负责处理用户与应用的交互，响应对view的操作，调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作），将js的ajax当作model，也即是数据层，通过ajax从服务器获取数据。</p><h4 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h4><blockquote><p>Model(模型): 数据保存 <br><br>View(视图): 用户界面 <br><br>ViewModel: view和model的连接器, 通过他实现双向绑定 <br></p></blockquote><p><img src="https://box.kancloud.cn/cf1408179b22cd06cb153688d97d4ae0_375x270.png" alt></p><p>MVVM与MVC最大的区别就是： 它实现了View和Model的自动同步，也就是当Model的属性发生改变时，我们不需要像以前一样手动操作D   om去改变View，Model的属性在改变后他会自动进行视图的更新。这就是神奇的双向绑定</p><h3 id="二、双向绑定实现原理"><a href="#二、双向绑定实现原理" class="headerlink" title="二、双向绑定实现原理"></a>二、双向绑定实现原理</h3><p>目前实现双向绑定主流的几种方法主要有</p><p><strong>1.发布订阅者</strong>：通过pub，sub的方式实现数据和视图绑定监听。</p><p><strong>2.脏值检测</strong>： 通过数据比对的方式进行检测数据是否有更新，最简单的方式肯定会是通过轮询的方式。angular采用的方式是只有在指定的事件触发之后才会进行脏值检测，比如：用户输入文本 http事件等。</p><p><strong>3.数据劫持</strong>：vue主要采用的是数据劫持结合发布-订阅者模式，通过es5的Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，出发相应的监听回调。</p><p>要实现MVVM的双向绑定需要实现以下几点：</p><blockquote><p>1.实现一个数据监听器 Observe，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者</p></blockquote><blockquote><p>2.实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数</p></blockquote><blockquote><p>3.实现一个Watcher，作为连接Observe和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</p></blockquote><p><img src="https://github.com/DMQ/mvvm/raw/master/img/2.png" alt></p><h4 id="1-实现Observe"><a href="#1-实现Observe" class="headerlink" title="1.实现Observe"></a>1.实现Observe</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var data = &#123;name: kidding&#125;;</span><br><span class="line">observe(data);</span><br><span class="line">data.name = &apos;yes&apos;;</span><br><span class="line"></span><br><span class="line">funtion observe(data) &#123;</span><br><span class="line">    if (!data || type data !== &apos;Object&apos;) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Object.keys(data).forEach(function()&#123;</span><br><span class="line">        defineReactive(data, key, data[key]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function defineReactive(data, key, val) &#123;</span><br><span class="line">    var dep = new Dep();</span><br><span class="line">    observe(val);</span><br><span class="line">    object.defineProperty(data, key, &#123;</span><br><span class="line">        enumerable: true,</span><br><span class="line">        configurable: false,</span><br><span class="line">        get: function() &#123;</span><br><span class="line">            Dep.target &amp;&amp; dep.addDep(Dep.target);</span><br><span class="line">            return val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function(newVal) &#123;</span><br><span class="line">            if (val === newVal) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(val, &apos;---&gt;&apos;, newVal);</span><br><span class="line">            val = newVal;</span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Dep() &#123;</span><br><span class="line">    this.subs = [];</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">    addSub: function(sub) &#123;</span><br><span class="line">        this.subs.push(sub)</span><br><span class="line">    &#125;,</span><br><span class="line">    notify: function() &#123;</span><br><span class="line">        this.subs.forEach(function(i)&#123;</span><br><span class="line">            i.update();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">    get: function(key) &#123;</span><br><span class="line">        Dep.target = this;</span><br><span class="line">        this.value = data[key];</span><br><span class="line">        Dep.target = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-实现Compile"><a href="#2-实现Compile" class="headerlink" title="2.实现Compile"></a>2.实现Compile</h4><p>compile主要做的事情就是解析模板指令，将模板中的变量替换为真实的数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知更新视图。</p><p><img src="https://github.com/DMQ/mvvm/raw/master/img/3.png" alt></p><p>因为解析遍历的过程有多次操作Dom，需要将实例根节点的el转换成文档碎片fragment进行解析编译操作。解析完成之后在将fragment添加回真是的dom节点中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">function Compile(el) &#123;</span><br><span class="line">    this.$el = this.isElementNode(el) ? el : document.querySelector(el);</span><br><span class="line">    if (this.$el) &#123;</span><br><span class="line">        this.$fragment = this.node2Fragment(this.$el);</span><br><span class="line">        this.init();</span><br><span class="line">        this.$el.appendChild(this.$fragment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Compile.prototype = &#123;</span><br><span class="line">    init: function() &#123;</span><br><span class="line">        this.compileElement(this.$fragment);</span><br><span class="line">    &#125;,</span><br><span class="line">    node2Fragment: function(el) &#123;</span><br><span class="line">        var fragment = document.createDocumentFragment(), child;</span><br><span class="line">        while(child = el.firstChild) &#123;</span><br><span class="line">            fragment.appendChild();</span><br><span class="line">        &#125;</span><br><span class="line">        return fragment;</span><br><span class="line">    &#125;,</span><br><span class="line">    compileElement: function(el) &#123;</span><br><span class="line">        var childNodes = el.childNodes, me = this;</span><br><span class="line">        [].splice.call(childNodes).forEach(function(node)&#123;</span><br><span class="line">            var text = node.textContent;</span><br><span class="line">            var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/;</span><br><span class="line">            if (me.isElementNode(node)) &#123;</span><br><span class="line">                me.compile(node);</span><br><span class="line">            &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123;</span><br><span class="line">                me.compileText(node, RegExp.$1);</span><br><span class="line">            &#125;</span><br><span class="line">            if (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">                me.compileElement(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    compile: function(node) &#123;</span><br><span class="line">        var nodeAttrs = node.attributes, me = this;</span><br><span class="line">        [].splice.call(nodeAttrs).forEach(function(attr)&#123;</span><br><span class="line">            var attrName = attr.name;</span><br><span class="line">            if (me.isDirective(attrName)) &#123;</span><br><span class="line">                var exp = attr.value;</span><br><span class="line">                var dir = attrName.substring(2);</span><br><span class="line">                if (me.isEventDirective(dir)) &#123;</span><br><span class="line">                    compileUtil.eventHandler(node, me.$vm, exp, dir);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var compileUtil = &#123;</span><br><span class="line">    text: function(node, vm, exp) &#123;</span><br><span class="line">        this.bind(node, vm, exp, &apos;text&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    bind: function(node, vm, exp, dir) &#123;</span><br><span class="line">        var updaterFn = udater[dir + &apos;Updater&apos;];</span><br><span class="line">        updaterFn &amp;&amp; updaterFn(node, vm[exp]);</span><br><span class="line">        new Watcher(vm, exp, function(value, oldValue) &#123;</span><br><span class="line">        // 一旦属性值有变化，会收到通知执行此更新函数，更新视图</span><br><span class="line">            updaterFn &amp;&amp; updaterFn(node, value, oldValue);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var updater = &#123;</span><br><span class="line">    textUpdater: function(node, value) &#123;</span><br><span class="line">        node.textContent = typeof value == &apos;undefined&apos; ? &apos;&apos; : value;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...省略</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-实现Watcher"><a href="#3-实现Watcher" class="headerlink" title="3.实现Watcher"></a>3.实现Watcher</h4><p>Watcher订阅者作为Observe和Compile之间通信的桥梁，主要做的事情是：</p><p>1.在自身实例化往属性订阅器dep里面添加自己</p><p>2.自身必须有一个update()方法</p><p>3.待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Watcher(vm, exp, cb) &#123;</span><br><span class="line">    this.cb = cb;</span><br><span class="line">    this.vm = vm;</span><br><span class="line">    this.exp = exp;</span><br><span class="line">    // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解</span><br><span class="line">    this.value = this.get(); </span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">    update: function() &#123;</span><br><span class="line">        this.run();// 属性值变化收到通知</span><br><span class="line">    &#125;,</span><br><span class="line">    run: function() &#123;</span><br><span class="line">        var value = this.get(); // 取到最新值</span><br><span class="line">        var oldVal = this.value;</span><br><span class="line">        if (value !== oldVal) &#123;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function() &#123;</span><br><span class="line">        Dep.target = this;// 将当前订阅者指向自己</span><br><span class="line">        var value = this.vm[exp];// 触发getter，添加自己到属性订阅器中</span><br><span class="line">        Dep.target = null;// 添加完毕，重置</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。</p><p> 基本上vue中数据绑定相关比较核心的几个模块也是这几个，猛戳<a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">这里</a> , 在src 目录可找到vue源码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MVVM原理实现&quot;&gt;&lt;a href=&quot;#MVVM原理实现&quot; class=&quot;headerlink&quot; title=&quot;MVVM原理实现&quot;&gt;&lt;/a&gt;MVVM原理实现&lt;/h2&gt;&lt;p&gt;在实现MVVM之前我们先来了解一下MVVM和MVC模式的差异&lt;/p&gt;
&lt;h3 id=&quot;一、MVVM-vs-MVC&quot;&gt;&lt;a href=&quot;#一、MVVM-vs-MVC&quot; class=&quot;headerlink&quot; title=&quot;一、MVVM vs MVC&quot;&gt;&lt;/a&gt;一、MVVM vs MVC&lt;/h3&gt;&lt;h4 id=&quot;MVC模式&quot;&gt;&lt;a href=&quot;#MVC模式&quot; class=&quot;headerlink&quot; title=&quot;MVC模式&quot;&gt;&lt;/a&gt;MVC模式&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;View(视图)： 用户界面 &lt;br&gt;&lt;br&gt;Controller(控制器): 业务逻辑 &lt;br&gt;&lt;br&gt;Model(模型): 数据保存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://lc-gold-cdn.xitu.io/9da7ababda36b88a5dd7.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="js, vue" scheme="http://yoursite.com/tags/js-vue/"/>
    
  </entry>
  
  <entry>
    <title>BFC布局</title>
    <link href="http://yoursite.com/2019/07/03/BFC%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2019/07/03/BFC布局/</id>
    <published>2019-07-03T03:19:35.000Z</published>
    <updated>2019-08-16T09:24:32.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BFC-块级格式化上下文"><a href="#BFC-块级格式化上下文" class="headerlink" title="BFC(块级格式化上下文)"></a>BFC(块级格式化上下文)</h2><blockquote><blockquote><p>是web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互区域。</p></blockquote></blockquote><a id="more"></a><h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><ol><li>根元素, 即HTML元素</li><li>float的值不为none</li><li>overflow的值不为visible</li><li>display的值为inline-block, table-cell, table-caption</li><li>position的值为absolute或fixed</li></ol><h3 id="布局规则"><a href="#布局规则" class="headerlink" title="布局规则"></a>布局规则</h3><ol><li>内部的box会在垂直方向, 一个接一个地放置(这点就是我们常见到的块级元素占一行)</li><li>box的垂直方向的距离由margin决定, 属于同一个BFC的两个相邻的margin会发生重叠, 与方向无关(垂直方向上的margin重合也就是我们常说的“坍塌现象”)</li><li>每个元素的margin box的左边, 与包含border box的左边相接触(对于从左往右的格式化, 否则相反). 即使存在浮动也是如此</li><li>BFC的区域不会与float box重叠</li><li>BFC就是页面上的一个隔壁的独立容器, 容器里面的子元素不会影响到外面的元素. 反之也如此</li><li>计算BFC的高度时, 浮动元素也参与计算</li></ol><h3 id="对比初学css时的规则"><a href="#对比初学css时的规则" class="headerlink" title="对比初学css时的规则"></a>对比初学css时的规则</h3><ol><li>block元素会扩展到与父元素同宽, 所以block元素会垂直排列</li><li>垂直方向上两个相邻的DIV margin重叠, 而水平方向上不会(这个说法就不完全正确)</li><li>浮动元素会接近左上方或右上方</li><li>为父元素设置overflow: hidden 或浮动元素, 则会包含浮动元素</li></ol><p><em>初学CSS规则背后更深层次的概念其实就是BFC布局规则</em></p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>自适应的两栏布局</li><li>可以阻止元素被浮动元素覆盖</li><li>可以包含浮动元素——清除内部浮动</li><li>分属不同的BFC时可以阻止margin重叠</li></ol><h3 id="通过BFC实现两栏布局"><a href="#通过BFC实现两栏布局" class="headerlink" title="通过BFC实现两栏布局"></a>通过BFC实现两栏布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        *&#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        .box &#123;</span><br><span class="line">            height: 100%;</span><br><span class="line">            width: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">        .left &#123;</span><br><span class="line">            float: left;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background-color: aquamarine;</span><br><span class="line">            width: 300px;</span><br><span class="line">            margin-right: 20px;</span><br><span class="line">        &#125;</span><br><span class="line">        .right &#123;</span><br><span class="line">            height: 300px;</span><br><span class="line">            background-color: blueviolet;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;BFC-块级格式化上下文&quot;&gt;&lt;a href=&quot;#BFC-块级格式化上下文&quot; class=&quot;headerlink&quot; title=&quot;BFC(块级格式化上下文)&quot;&gt;&lt;/a&gt;BFC(块级格式化上下文)&lt;/h2&gt;&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;是web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互区域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
</feed>
